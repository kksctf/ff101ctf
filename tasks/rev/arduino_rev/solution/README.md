# Рикролл
Author: `denis`

## Desc

> HW + RE

Будь внимателен, не дай себя провести!

[Схема](./scheme.png)

[Прошивка](./fw.elf)

## Flag

```
ptctf{arduin0_n3v3r_g0nn4_giv3_y0u_up}

```

## Solve

### Описание задачи

Игроку необходимо наиграть мелодию, используя "пианино", сделанное на Arduino Uno. В данной схеме кнопки соответствуют "клавишам", которые привязаны к следующим звукам:

```
Номер      Пин    Нота
-------------------------
1          12     NOTE_GS4
2          11     NOTE_AS4   
3          10     NOTE_C5
4          9      NOTE_CS5
5          7      NOTE_DS5
6          6      NOTE_F5
7          5      NOTE_FS5

```
К 8 пину подключен баззер.

При правильном нажатии один раз мигает светодиод, а в последовательный порт пишется сообщение об успехе, в противном случае светодиод мигает три раза, а игроку необходимо начать все сначала.
После успешного ввода мелодии, игрок услышит победный проигрыш, а в последовательный порт будет записан флаг.

Правильная последовательность:

```
NOTE_AS4, NOTE_AS4, NOTE_GS4, NOTE_GS4, NOTE_F5, NOTE_F5, NOTE_DS5, NOTE_AS4, NOTE_AS4, NOTE_GS4, NOTE_GS4, NOTE_DS5, NOTE_DS5, NOTE_CS5, NOTE_C5, NOTE_AS4
```

или, переводя на номера "клавиш":

```
2, 2, 1, 1, 6, 6, 5, 2, 2, 1, 1, 5, 5, 4, 3, 2
```

Флаг хранится прямо в прошивке, спрятанный с помощью `xor` по маске "NEVAGONNAGIVENEVAGONNAGIVE".

Решение задачи в любом случае должно начинаться с построения аналогичной схемы в любом конструкторе, например, я пользовался https://wokwi.com, он позволяет, в том числе, загрузить прошивку в формате elf. Дальше есть два решения

### Решение 1

Можно заметить, что при нажатии клавиш, плата ведет себя по разному. Игрок, может методом подбора определить верную последовательность и прочитать флаг.



### Решение 2
Я подумал, что для упрощения можно дать elf с символами, а не hex файл. В любом случае надо будет почитать пару строк ассемблерного кода.

Игрок может по картинке определить, что данная прошивка принадлежит устройству Arduino UNO, на базе avr8. Далее, используя Ghidra, игрок может загрузить туда данный elf-файл, и проанализировать его работу.
Замысел задачи подразумевает, что содержимое флага не зависит от вводимых данных, поэтому можно найти указатели на строки, определить место их использования, и там найти спрятанный флаг.
Сложности:

    1. AVR - так себе архитектура для современных декомпиляторов, но в каком-то виде есть в Ghidra.
    2. Но даже она не справляется полностью из-за использования глобальных регистров для хранения локальных переменных.
    3. Нужно определить, как передаются параметры и как указатели помещаются в регистры. Рассмотрим пример:
   ```
        code:0792 fe  01           movw       Z,Y
        code:0793 eb  5e           subi       Zlo ,0xeb
        code:0794 fe  4f           sbci       Zhi ,0xfe
```
   

   Здесь, в первой строчке, значение регистра `Y` (размера 2 байта), который хранит значение индекса условного массива, помещается в регистр `Z` (такого же размера). Далее, из старшей (`hi`) и младшей (`lo`) частей вычитаются значения `0xeb` и `0xfe` соответственно. Тонкость заключается в том, что операции вычитания отличаются: `subi` вычитает непосредственное значение, а `sbci` - вычитает значение с переносом. В данном примере это означает, что, при значении `Y == 0`, операция на строке 0793 будет выглядеть как `subi Zlo ,0xeb = 0x0 - 0xeb + 0x0 = 0x15`, а на строке 0794 -  `sbci Zhi ,0xfe = 0xff - 0xfe + 0x0 = 0x1`, что даст значение в `Z = 0x115`. Также необходимо отметить, что в AVR используется не фон-неймановская, а гарвардская архитектура, и данное значение указыает на область данных.

    4. Стандартное соглашение для вызовов для данной платформы в gcc подразумевает, что первый параметр передается через пару регистров R25:R24, второй - R23:R22 и т.д.


Если игрок успешно разберется с этими тонкостями, то он быстро обнаружит, что по адресу 0751 начинается блок кода, который выводит в последовательеый порт данные, неизвестные до этого. Далее, там же, будет видно, что программа пишет заголовок флага и результат операции XOR от двух массивов. Дальше дело техники - https://gchq.github.io/CyberChef/#recipe=From_Hex('Auto')XOR(%7B'option':'UTF8','string':'NEVAGONNAGIVENEVAGONNAGIVE'%7D,'Standard',false)&input=MkYgMzcgMzIgMzQgMkUgMjEgN0UgMTEgMkYgNzQgM0YgNjUgMzcgMTEgMjIgNjYgMkYgMjkgN0IgMTEgMjkgMjggMzEgN0EgMDkgM0MgN0UgMzAgMDkgMzQgMzc


